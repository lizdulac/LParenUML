package controllers;
import controllers.Command.Scope;
import controllers.Command.Action;
import model.*;

import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.scene.text.TextAlignment;
import javafx.scene.control.Menu;
import javafx.scene.control.MenuBar;
import javafx.scene.control.MenuItem;
import javafx.scene.control.SeparatorMenuItem;
import javafx.scene.control.Tooltip;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.scene.control.Button;
import javafx.scene.control.ButtonBar.ButtonData;
import javafx.scene.control.ButtonType;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Background;
import javafx.scene.layout.BackgroundFill;

import java.io.File;
import java.io.IOException;
import java.util.Optional;

import javafx.util.Duration;
import javafx.stage.Stage;
import javafx.stage.Screen;
import javafx.stage.StageStyle;
import javafx.stage.FileChooser;
import javafx.geometry.Pos;
import javafx.geometry.Insets;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.ObservableList;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;

/**
 * 
 * @author 
 *
 */
public class AppCtrl
{
    /************************ APPCTRL CLASS MEMBERS ***********************/
    private static AppCtrl appCtrl;
    private PropertiesCtrl propCtrl;
    private CanvasCtrl canvasCtrl;
    private ToolState toolState;
    private Button prevState;
    protected UGraph theGraph;
    private Stage appStage;
    private Scene appScene;
    protected Stage sideStage;
    private Scene sideScene;
    private FileIO fileIO;
    private History history;
    private VBox propSlider;

    /*********************** APPCTRL FINAL VARIABLES *********************/
    private final double menuH = 39;
    private final double margin = 50;
    private final double cornerRadius = 50;
    private final double toolW = cornerRadius + margin;
    private final String appName = "RParen - a UML Diagram Editor by LParen - ";
    private final String selected =  ".button {-fx-background-color:linear-gradient(#f8f8f8, #dcdcdc),"
            + "linear-gradient(#ffffff 0%, #dfdfdf 20%, #dcdcdc 100%),linear-gradient(#e0e0e0 0%, #fcfcfc 50%);"
            + "-fx-background-color: white;-fx-background-radius: 8,7,6;-fx-background-insets: 0,1,2;"
            + "-fx-focus-color: transparent;-fx-effect: dropshadow( three-pass-box , #0E92F0 , 10, 0 , 0 , 1 );"
            + "-fx-text-fill: #0E92F0;-fx-border-color:#aaaaaa;-fx-border-width: 2 2 2 2;"//#75eae8;";
            + "-fx-border-radius: 8,7,6;";
    private final String unselected = ".button {" + "-fx-background-color:linear-gradient(#f2f2f2, #d6d6d6),"
            + "linear-gradient(#fcfcfc 0%, #d9d9d9 20%, #d6d6d6 100%),linear-gradient(#dddddd 0%, #f6f6f6 50%);"
            + "-fx-background-radius: 8,7,6;-fx-background-insets: 0,1,2;-fx-text-fill: black;"
            + "-fx-focus-color: transparent;}";
    private final String canvasBgHex = "#F2F2F2";
    private final Background marginBg = new Background (new BackgroundFill (Color.WHITE, null, null));
    private final Background transparent = new Background (new BackgroundFill (Color.TRANSPARENT, null, null));

    /************************* APPCTRL CONSTRUCTOR *********************/
    /**
     * AppCtrl follows a singleton pattern so that
     * only one instance is ever created. This is the
     * only constructor & it is private. It is called
     * only one time, inside getAppController()
     * 
     * @param stage should be the JavaFX 'primaryStage' generated by Application.start()
     */
    private AppCtrl (Stage stage)
    {
        // initialization
        BorderPane borderPane;
        theGraph = new UGraph ();
        toolState = ToolState.SELECT_MOVE;
        canvasCtrl = new CanvasCtrl (this);
        propCtrl = new PropertiesCtrl (this);
        fileIO = new FileIO (this, canvasCtrl.canvasView);
        history = new History ();

        // appStage - configure primary application window
        appStage = stage;
        borderPane = configureAppStage ();
        appScene = new Scene (borderPane);
        appStage.setScene (appScene);
        appStage.show ();

        // sideStage - configure the side panels
        configureSideStage (borderPane);
        sideStage.setScene (sideScene);
        sideStage.show ();

        // start - GUI interface is now visible
        System.out.println ("\n******* Start *******\n");
        
        appStage.setHeight (Screen.getPrimary ().getVisualBounds ().getHeight ());
        sideStage.setHeight (Screen.getPrimary ().getVisualBounds ().getHeight ());
    }


    /*********************** APPCTRL GRAPH FUNCTIONS *******************/
    /**
     * 
     * @return
     */
    public UGraph getGraph ()
    {
        return theGraph;
    }
    
    /**
     * 
     * @param id
     * @param name
     */
    public void addNode (Integer id, String name)
    {
        theGraph.addNode (id, name);
    }
    
    /**
     * 
     * @param id
     * @return
     */
    public UNode getNode(int id)
    {
        return theGraph.getNode (id);
    }
    
    /**
     * 
     * @param id
     */
    public void removeNode (Integer id)
    {
        cleanEdges (getNode(id));
        theGraph.removeNode (id);
    }
    
    /**
     * 
     * @param n1
     * @param n2
     * @param edge
     */
    public void addEdge (Integer id, UNode n1, UNode n2, String name)
    {
        theGraph.addEdge (id, n1, n2, name);
    }
    
    /**
     * 
     * @param id
     * @return
     */
    public UEdge getEdge (Integer id)
    {
        return theGraph.getEdge (id);
    }
    
    /**
     * 
     * @param id
     */
    public void removeEdge (Integer id)
    {
        theGraph.removeEdge (id);
        eraseEdge(id);
    }
    
    /*************************** UNODE FUNCTIONS **************************/
    /**
     *  Clean the edges off of a Node.
     * 
     * @version 3.0 Inbound Iteration 3 
     */
    public void cleanEdges(UNode n)
    {       
        //clean outgoing edges and their ends 
        if (n != null){
            for (UEdge e: n.getOutEdges())
            {
                theGraph.removeEdgeFromIn(e.getId ());
                eraseEdge(e.getId ());
                }
        
            //clean incoming edges and their starts
            for (UEdge e : n.getInEdges())
            {
                theGraph.removeEdgeFromOut(e.getId ());
                eraseEdge(e.getId ());
                }
            }
        }
    
    /**
     * Erases Line representing Edge from canvas,
     * but leaves model unchanged
     * 
     * @param id
     */
    public void eraseEdge (Integer id)
    {       
        executeCommand (packageAction(Action.DELETE_EDGE, Scope.CANVAS, id), false);
    }  
    /**
    *
    * 
    * @param id
    */
   public ObservableList<String> getAsList(Integer id)
   {
       return theGraph.getNode(id).getAsList();
   }

   /**
   *
   * 
   * @param id
   */
  public void setFromList(Integer id, ObservableList<String> nodeData)
  {
      theGraph.getNode(id).setFromList(nodeData);
  }

   /**
   *
   * 
   * @param
   */
   public void refreshPropData(ObservableList<String> nodeData)
   {
       propCtrl.refreshPropData(nodeData);
   }

   /**
   *
   * 
   * @param
   */
   public void refreshVNode(Integer id, String name)
   {
       canvasCtrl.refreshVNode(id, name);
   }
    
    /**
     * Packages the parameters and the type of action into a Command class. The
     * execute_command method or other invoker style methods are responsible for
     * recasting the objects.
     * 
     * @param type
     *            declared in the Action enum in @Command.java
     * @param objects
     *            a templated list of parameters cast as objects.
     */
    private Command packageAction (Action type, Scope scope, Object... objects)
    {
        // add scope
        return new Command (type, scope, objects);
    }
    

    /*********************** APPCTRL GENERAL GETTERS *******************/
    /**
     * 
     * @return
     */
    public PropertiesCtrl getPropCtrl ()
    {
        return propCtrl;
    }
    
    public CanvasCtrl getCanvasCtrl ()
    {
        return canvasCtrl;
    }
    
    public boolean propIsVisible ()
    {
        return propCtrl.isVisible();
    }
    
    public String getSelectedStyle()
    {
    	return selected;
    }
    
    public String getUnselectedStyle()
    {
    	return unselected;
    }
    
    /**
     * Exposes the tool width, which
     * is needed to build the GUI.
     * 
     * @return the tool width, which is cornerRadius + margin
     */
    public double getToolWidth ()
    {
        return toolW;
    }

    /**
     * Exposes the tool state, which is needed to
     * perform the correct actions on the canvas.
     * 
     * @return enum representing currently active tool
     */
    public ToolState getToolState ()
    {
        return toolState;
    }

    /**
     * Enforces a singleton pattern, ensuring that
     * only a single instance of AppCtrl is ever created.
     * 
     * @param stage should be the JavaFX 'primaryStage' generated by Application.start()
     * @return the application controller singleton
     */
    public static AppCtrl getAppController (Stage stage)
    {
        if (appCtrl == null)
        {
            appCtrl = new AppCtrl (stage);
        }
        return appCtrl;
    }

    /*********************** APPCTRL CONFIGURATIONS ********************/
    /**
     * This offset is necessary to overcome platform inconsistencies
     * in how a window is maximized vertically. Essentially the
     * offset is the difference between the actual height of the
     * screen and the height of a vertically maximized window. Ideally
     * these two values would always be the same and the offset would
     * be zero but this is not always true.
     * 
     * @param borderPane layout manager pane for primary application window
     * @return the calculated offset
     */
    private double calculateOffset (BorderPane borderPane)
    {
        double titleBarH = appScene.getY ();
        double appWindowH = appScene.getWindow ().getHeight ();
        double currentCanvasH = ((Pane) borderPane.getCenter ()).getHeight ();
        double anchorOffset = appWindowH - titleBarH - currentCanvasH - (margin * 2);

        if (anchorOffset < 0)
        {
            anchorOffset = 0;
        }
        return anchorOffset;
    }

    /**
     * Configure settings for primary application window (appStage).
     * This should be called before the application
     * window is made visible with Window.show()
     * 
     * @return layout manager pane for primary application window
     */
    private BorderPane configureAppStage ()
    {
        double canvasW = 800;
        double canvasH = 500;

        // Stage settings
        appStage.setMinWidth (canvasW);
        appStage.setMinHeight (canvasH);
        appStage.initStyle (StageStyle.DECORATED);
        appStage.setTitle (appName + "Untitled Document");

        // Set app titlebar icon to LParen logo.
        // Logo image file should be in root directory with Main.java
        try {
              appStage.getIcons ().add (new Image ("LParen.jpg"));
        } catch (Exception e) {
              System.out.println ("AppCtrl ConfigStage: unable to render LParen Icon");
        }

        // center app horizontally on screen
        double xScreenCenter = Screen.getPrimary ().getVisualBounds ().getWidth () / 2;
        appStage.setX (xScreenCenter - (canvasW + toolW * 2) / 2);

        appStage.setY (0);
        return configureBorderPane (canvasW, canvasH);
    }

    /**
     * Configure settings & add elements to borderPane.
     * It is the layout manager for primary application window.
     * 
     * @param canvasW initial width of the canvas
     * @param canvasH initial height of the canvas
     * @return layout manager pane for primary application window
     */
    private BorderPane configureBorderPane (double canvasW, double canvasH)
    {
        BorderPane menuBar = configureMenuBar (canvasW);
        Pane canvas = canvasCtrl.getCanvas ();
        Pane rightCorners = new Pane ();
        BorderPane borderPane = new BorderPane ();

        // Margins
        StackPane topMargin = new StackPane (menuBar);
        StackPane btmMargin = new StackPane ();
        StackPane leftMargin = new StackPane ();
        StackPane rightMargin = new StackPane (rightCorners);
        StackPane.setMargin (rightCorners, new Insets (0, margin, 0, 0));
        StackPane.setAlignment (menuBar, Pos.TOP_LEFT);

        // Background Colors
        borderPane.setBackground (marginBg);
        topMargin.setBackground (marginBg);
        btmMargin.setBackground (marginBg);
        leftMargin.setBackground (marginBg);
        rightMargin.setBackground (marginBg);
        canvas.setStyle       ("-fx-background-color: " + canvasBgHex + ";"+
                               "-fx-background-radius: " + cornerRadius + " 0 0 " + cornerRadius + ";");
        rightCorners.setStyle ("-fx-background-color: " + canvasBgHex + ";"+
                               "-fx-background-radius: 0 " + cornerRadius + " " + cornerRadius + " 0;");

        // Dimensions
        canvas.setPrefWidth (canvasW);
        canvas.setPrefHeight (canvasH);
        topMargin.setPrefHeight (margin);
        btmMargin.setPrefHeight (margin - menuH);
        leftMargin.setPrefWidth (margin);
        rightMargin.setPrefWidth (toolW);
        rightCorners.setPrefWidth (cornerRadius);

        // BorderPane Layout
        borderPane.setCenter (canvas);
        borderPane.setTop (topMargin);
        borderPane.setBottom (btmMargin);
        borderPane.setLeft (leftMargin);
        borderPane.setRight (rightMargin);
        BorderPane.setAlignment (canvas, Pos.TOP_LEFT);
        return borderPane;
    }

    /**
     * Create new MenuBar, add items to it, and set the
     * appropriate event handlers. The menuBar is positioned
     * within the topMargin of the borderPane layout manager.
     * 
     * @param canvasW initial width of the canvas
     * @return the JavaFX MenuBar that was created
     */
    private BorderPane configureMenuBar (double canvasW)
    {
    	final double fontSize = 15;
        final double spacing = 90;
    	
        // ************ FILE DROPDOWN ************
        Menu fileMenu = new Menu ("File");        
        // Create MenuItems
        SeparatorMenuItem fBreak1 = new SeparatorMenuItem();
        MenuItem newF = new MenuItem ("New");  
        MenuItem open = new MenuItem ("Open");
        MenuItem save = new MenuItem ("Save As");
        MenuItem newW = new MenuItem ("New Window");
        SeparatorMenuItem fBreak2 = new SeparatorMenuItem();
        MenuItem stats = new MenuItem ("Show Diagram Statistics");
        SeparatorMenuItem fBreak3 = new SeparatorMenuItem();
        MenuItem exit = new MenuItem ("Exit");
        SeparatorMenuItem fBreak4 = new SeparatorMenuItem();
        
        // Add Items
        fileMenu.getItems().add(fBreak1);
        fileMenu.getItems().add(newF);
        fileMenu.getItems().add(open);
        fileMenu.getItems().add(save);
        fileMenu.getItems().add (newW);
        fileMenu.getItems().add(fBreak2);
        fileMenu.getItems().add(stats);
        fileMenu.getItems().add(fBreak3);
        fileMenu.getItems().add(exit);
        fileMenu.getItems().add(fBreak4);
        
        // EventHandlers
        newF.setOnAction (newFile);
        open.setOnAction (openFile);
        save.setOnAction (saveFile);
        newW.setOnAction (newWindow);
        stats.setOnAction(e -> ModelUtil.printStats (getGraph()));
        exit.setOnAction(exitEvent);
        
        // ************ EDIT DROPDOWN ************
        Menu editMenu = new Menu ("Edit");
        // Create MenuItems
        SeparatorMenuItem eBreak1 = new SeparatorMenuItem();
        MenuItem undo = new MenuItem ("Undo");
        MenuItem redo = new MenuItem ("Redo");
        SeparatorMenuItem eBreak2 = new SeparatorMenuItem();
        MenuItem prop = new MenuItem ("Properties");
        SeparatorMenuItem eBreak3 = new SeparatorMenuItem();
        
        // Add Items
        editMenu.getItems().add(eBreak1);
        editMenu.getItems().add(undo);
        editMenu.getItems().add(redo);
        editMenu.getItems().add(eBreak2);
        editMenu.getItems().add(prop);
        editMenu.getItems().add(eBreak3);
        
        // EventHandlers
        undo.setOnAction (e -> undo());
        redo.setOnAction (e -> redo());
        prop.setOnAction (e -> { if( !propCtrl.isVisible())   toggleSlider() ;});
        // only toggle the slider if it is currently hidden
        
        // ************ VIEW DROPDOWN ************
        Menu viewMenu = new Menu ("View");
        // Create MenuItems
        SeparatorMenuItem vBreak1 = new SeparatorMenuItem();        
        MenuItem zoomIn = new MenuItem ("Zoom In  ( + )");
        MenuItem zoomOut = new MenuItem("Zoom Out  ( - )");
        SeparatorMenuItem vBreak2 = new SeparatorMenuItem();        
        MenuItem reset = new MenuItem ("Reset Zoom  (100%)");
        SeparatorMenuItem vBreak3 = new SeparatorMenuItem();
        
        // Add Items
        viewMenu.getItems().add(vBreak1);
        viewMenu.getItems().add(zoomIn);
        viewMenu.getItems().add(zoomOut);
        viewMenu.getItems().add(vBreak2);
        viewMenu.getItems().add(reset);
        viewMenu.getItems().add(vBreak3);
        
        // EventHandlers
        zoomIn.setOnAction(zoomInClick);
        zoomOut.setOnAction(zoomOutClick);
        reset.setOnAction (zoomReset);        
        
        // ******************** MAIN MENUBAR ********************
        // MenuBar
        MenuBar mainMenu = new MenuBar(fileMenu, editMenu, viewMenu);
        StackPane.setAlignment(mainMenu, Pos.TOP_LEFT);
        mainMenu.setMinHeight(menuH);
        // StackPane
        StackPane menuPane = new StackPane(mainMenu);        
        menuPane.setPrefWidth(margin + (canvasW / 2) - (spacing * 3));
        
        // Menu Styling
        fileMenu.setStyle("-fx-padding: 6;");
        editMenu.setStyle("-fx-padding: 6;");
        viewMenu.setStyle("-fx-padding: 6;");        
        mainMenu.setStyle("-fx-padding: 0 0 0 6; -fx-font-size: " + fontSize);
        mainMenu.setBackground (transparent);
        
        // ******************** ZOOM TOOLBAR ********************
        // Create Buttons
    	Button zoomOutButton = new Button ("-");
    	Button zoomInButton = new Button ("+");
    	Button zoomResetButton = new Button ("Reset Zoom");
        zoomOutButton.setStyle("-fx-font-weight: bold; -fx-font-size: " + fontSize);
    	zoomInButton.setStyle("-fx-font-weight: bold; -fx-font-size: " + fontSize);
    	zoomResetButton.setStyle("-fx-font-size: " + fontSize);
    	
        // EventHandlers
    	zoomOutButton.setOnAction(zoomOutClick);
    	zoomInButton .setOnAction(zoomInClick);
    	zoomResetButton.setOnAction (zoomReset);
    	
    	// zoomButtons HBox
    	HBox zoomButtons = new HBox((spacing / 10), zoomOutButton, zoomResetButton, zoomInButton);
    	zoomButtons.setMinWidth(spacing * 2);       
        Pane zoomLeft = new Pane();
        Pane zoomRight = new Pane();
        
        // zoomHBox
        HBox zoomHBox = new HBox(zoomLeft, zoomButtons, zoomRight);
    	zoomHBox.setMinHeight(menuH);
    	HBox.setHgrow(zoomLeft, Priority.ALWAYS);
    	HBox.setHgrow(zoomButtons, Priority.NEVER);
    	HBox.setHgrow(zoomRight, Priority.ALWAYS);
    	
        // ******************** HISTORY TOOLBAR ********************
        // Undo Button
        Text undoText = new Text("Undo ");
        Text undoArrow = new Text(" " + Character.toString ((char) 0x293a));       
        HBox undoLabel = new HBox(4, undoArrow, undoText);
        Button undoButton = new Button (null, undoLabel);
        undoButton.resizeRelocate(0, 0, spacing, 0);
    	undoArrow.setStyle("-fx-font-size: " + (fontSize + 5));
    	undoText.setStyle("-fx-font-size: " + (fontSize + 1));
        
        // Redo Button
        Text redoText = new Text(" Redo");
        Text redoArrow = new Text(Character.toString ((char) 0x293b) + " ");       
        HBox redoLabel = new HBox(3, redoText, redoArrow);
        Button redoButton = new Button(null, redoLabel);
        redoButton.resizeRelocate(0, 0, spacing, 0);   
    	redoArrow.setStyle("-fx-font-size: " + (fontSize + 5));
    	redoText.setStyle("-fx-font-size: " + (fontSize + 1));
    	
        // EventHandlers
    	undoButton.setOnAction(e -> undo ());
        redoButton.setOnAction (e -> redo ());
        
        // History AnchorPane & HBox
        AnchorPane historyAnchor = new AnchorPane(undoButton, redoButton);
        HBox historyHBox = new HBox(historyAnchor);
        AnchorPane.setRightAnchor(redoButton, 0.0);
        AnchorPane.setRightAnchor(undoButton, redoButton.getWidth());
        historyAnchor.prefWidthProperty().bind (mainMenu.prefWidthProperty());
        historyAnchor.setStyle ("-fx-border-color: darkgray; -fx-border-width: 0 0 2 0");
        
        // ******************** GLOBAL MENU SETTINGS ********************
    	Pane menuSpacer = new Pane();
    	menuSpacer.setPrefHeight(margin - menuH);   
        menuPane.setStyle ("-fx-border-color: darkgray; -fx-border-width: 0 0 2 0");
        zoomHBox.setStyle ("-fx-border-color: darkgray; -fx-border-width: 0 0 2 0;");
    	historyHBox.setStyle ("-fx-padding: 0 " + toolW + " 0 0;");
    	
    	// borderPane acts as layout manager for entire top menu
    	BorderPane borderPane = new BorderPane();
    	borderPane.setLeft(menuPane);
    	borderPane.setCenter(zoomHBox);
    	borderPane.setRight(historyHBox);
    	borderPane.setBottom(menuSpacer);       
    	return borderPane;
    }

    /**
     * Configure settings for the secondary window (sideStage).
     * This window contains the toolButtons and the properties
     * inspector. This method should be called before the
     * window is made visible with Window.show()
     * 
     * @param borderPane layout manager pane for primary application window
     */
    private void configureSideStage (BorderPane borderPane)
    {
        // initialization
        double xOrigin = borderPane.localToScreen (borderPane.getLayoutX (), borderPane.getLayoutY ()).getX ()
                + borderPane.getWidth () - toolW;
        double anchorOffset = calculateOffset (borderPane);
        AnchorPane anchorPane = new AnchorPane ();
        propSlider = configurePropSlider ();
        Pane sidePane = configureSidePane ();
        sideScene = new Scene (anchorPane);
        sideStage = new Stage ();

        // anchorPane
        anchorPane.setPrefWidth (toolW * 4);
        anchorPane.prefHeightProperty ().bind (appScene.heightProperty ());
        anchorPane.getChildren ().addAll (propSlider, sidePane);
        AnchorPane.setBottomAnchor (sidePane, anchorOffset);
        anchorPane.setBackground (transparent);

        // propSlider
        propSlider.setLayoutX (cornerRadius);

        // sideStage
        sideStage.initStyle (StageStyle.TRANSPARENT);
        sideScene.setFill (Color.TRANSPARENT);
        sideStage.initOwner (appStage);
        sideStage.setX (xOrigin);
        sideStage.setY (0);

        // listen for changes to appStage
        appStage.heightProperty ().addListener (appChangeH);
        appStage.widthProperty ().addListener (appChangeW);
        appStage.yProperty ().addListener (appChangeY);
        appStage.xProperty ().addListener (appChangeX);

        //*** Development / Debugging Buttons ***
        //  Setting these event handlers requires traversing the JavaFX Scene Graph.
        //  The code is UGLY but:
        //     - it works :)
        //     - this code (and the 2 buttons) will be eventually be deleted
        //
        // PropSlider button triggers toggleSlider()
        //((Button) ((Pane) ((Pane) anchorPane.getChildren ().get (1)).getChildren ().get (1)).getChildren ().get (5))
        //        .setOnAction (e -> toggleSlider ());
        
        // PrintStats button triggers ModelUtil.printStats()
        //((Button) ((Pane) ((Pane) anchorPane.getChildren ().get (1)).getChildren ().get (1)).getChildren ().get (5))
        //        .setOnAction (e -> ModelUtil.printStats (getGraph()));
    }

    /**
     * Create new Pane (sidePane) & add elements to it.
     * This sidePane contains the toolButtons panel.
     * This sidePane exists within the main
     * anchorPane of the sideStage window.
     * 
     * @return the Pane that was created
     */
    private Pane configureSidePane ()
    {
        // Initialization
        Pane marginOverlay = new Pane ();
        Pane toolButtons = configureToolButtons ();
        Pane sidePane = new Pane (marginOverlay, toolButtons);

        // Background Colors
        sidePane.setBackground (transparent);
        marginOverlay.setBackground (marginBg);
        toolButtons.setBackground (marginBg);
        toolButtons.setStyle ("-fx-border-color: darkgray; -fx-border-width: 0 0 2 2;");

        // Dimensions
        sidePane.prefHeightProperty ().bind (appScene.heightProperty ());
        marginOverlay.prefHeightProperty ().bind (appScene.heightProperty ().subtract (margin));
        marginOverlay.setPrefWidth (margin);
        toolButtons.setPrefWidth (toolW);

        // Layout
        marginOverlay.setLayoutX (cornerRadius);
        toolButtons.setLayoutY (menuH - 7);
        return sidePane;
    }

    /**
     * Create new Pane (toolButtons), add buttons,
     * and set the buttonClick event handler. The
     * toolButtons pane is contained by sidePane.
     * 
     * @return the Pane that was created
     */
    private Pane configureToolButtons ()
    {
        /*
         * Unicode numbers for button icons, in order:
         * MOVE, SELECT, ADD_NODE, ADD_EDGE, DELETE
         */
        double fontSize = 22.0;
        double panelSpacing = 22.0;
        Pos panelAlignment = Pos.CENTER;
        Font buttonsFont = Font.font ("sans-serif", FontWeight.BOLD, fontSize);
        
        final int[] UCodes = new int[] { 0x2725, 0x261D, 0x274F, 8594, 0x2718 };
        final String[] buttonNames = new String[] { "Move Graph", "Select / Move", "Create Class Box", "Create Relationship", "Delete" };

        VBox toolButtons;
        toolButtons = new VBox (panelSpacing);
        toolButtons.setAlignment (panelAlignment);

        // create Button objects
        Button[] buttons = new Button[UCodes.length];
        for (int i = 0; i < UCodes.length; ++i)
        {
            buttons[i] = new Button (Character.toString ((char) UCodes[i]));
            // Set text to be displayed when button is hovered over
            if (i < buttonNames.length)
            {
                final Tooltip tt = new Tooltip ();
                tt.setText (buttonNames[i]);
                buttons[i].setTooltip (tt);
            }
            buttons[i].setFont (buttonsFont);
            buttons[i].setStyle (unselected);
            toolButtons.getChildren ().add (buttons[i]);

            if (i < ToolState.values ().length)
            {
                buttons[i].setUserData (ToolState.values ()[i]);
                buttons[i].setOnAction (buttonClick);
            }
            else
            {
                buttons[i].setUserData (i);
                buttons[i].setOnAction (buttonClick);
            }
        }
        
        toolButtons.setPrefHeight ((fontSize + panelSpacing) * (buttons.length + 3));
        return toolButtons;
    }



    /**
     * 
     */
    public EventHandler<ActionEvent> buttonClick = new EventHandler<ActionEvent> ()
    {
        @Override
        public void handle (ActionEvent e)
        {
            Button sourceButton = (Button) e.getSource ();
            try {
                int val =(int) sourceButton.getUserData ();
                if (val == ToolState.values ().length)
                {
                    canvasCtrl.zoomIn (0.1);
                }
                else if (val == ToolState.values ().length + 1)
                {
                    canvasCtrl.zoomIn (-0.1);
                }
                return;
            } catch (ClassCastException ex)
            {
                
            }
            ToolState buttonState = (ToolState) (sourceButton.getUserData ());

            switch (buttonState)
            {
            case MOVE_GRAPH:
                toolState = ToolState.MOVE_GRAPH;
                break;
            case SELECT_MOVE:
                toolState = ToolState.SELECT_MOVE;
                break;
            case ADD_NODE:
                toolState = ToolState.ADD_NODE;
                break;
            case ADD_EDGE:
                toolState = ToolState.ADD_EDGE;
                break;
            case DELETE:
                toolState = ToolState.DELETE;
                break;
            default:
                toolState = ToolState.SELECT_MOVE;
            }
            System.out.println ("TSTATE: changed to " + toolState);
            sourceButton.setStyle (selected);
            if (prevState != null && prevState != sourceButton)
            {
                prevState.setStyle (unselected);
            }
            prevState = sourceButton;
        }
    };

    /**
     * Create new Pane (propSlider) & add elements to it.
     * This propSlider contains the properties inspector.
     * This propSlider pane exists within the main
     * anchorPane of the sideStage window.
     * 
     * @return the Pane that was created
     */
    private VBox configurePropSlider ()
    {
        // initialization
        Pane properties = propCtrl.getProperties ();
        Pane topSpacer = new Pane ();
        VBox propSlider = new VBox ();

        // topSpacer
        topSpacer.setBackground (transparent);
        topSpacer.prefHeightProperty ()
                .bind (appScene.heightProperty ().subtract (properties.heightProperty ()).divide (2.0));
        topSpacer.setPrefWidth (toolW);

        // propSlider
        propSlider.getChildren ().addAll (topSpacer, properties);
        propSlider.setBackground (transparent);
        propSlider.setPrefWidth (toolW);
        return propSlider;
    }
    
    /**
     * The slider has two possible states: hidden or visible.
     * This method toggles the slider from its current state
     * to the opposite state. Visually the transition is an
     * animation of the pane sliding in/out from behind the
     * main application window.
     * 
     * @param propSlider the Pane that contains the properties inspector
     */
    protected void toggleSlider ()
    {
        double endW;
        DoubleProperty currentW = new SimpleDoubleProperty (propSlider.getWidth ());
        double propW = propCtrl.getWidth ();
        Timeline timeline = new Timeline ();

        if (propCtrl.isVisible ())
        {
            endW = 0;
            timeline.setOnFinished (event ->
            {
                propCtrl.toggleVisible ();
                System.out.println ("PROPTY: visible changed to " + propCtrl.isVisible ());
            });
        } else
        {
            endW = propW;
            propCtrl.toggleVisible ();
            timeline.setOnFinished (
                event -> System.out.println ("PROPTY: visible changed to " + propCtrl.isVisible ()));
        }

        currentW.addListener ( (obs, oldV, newV) -> propSlider.setPrefWidth (newV.doubleValue ()));
        timeline.getKeyFrames ().add (new KeyFrame (Duration.seconds (0.2), new KeyValue (currentW, endW)));
        timeline.play ();
    }
    
    public EventHandler<ActionEvent> zoomReset = new EventHandler<ActionEvent>()
    {
        @Override
        public void handle (ActionEvent e)
        {
            canvasCtrl.zoomReset ();
        }
    };
    
    public EventHandler<ActionEvent> zoomInClick = new EventHandler<ActionEvent>()
    {
        @Override
        public void handle (ActionEvent e)
        {
            canvasCtrl.zoomIn(-0.1);
        }
    };

    public EventHandler<ActionEvent> zoomOutClick = new EventHandler<ActionEvent>()
    {
        @Override
        public void handle (ActionEvent e)
        {
            canvasCtrl.zoomIn(0.1);
        }
    };
    
    /*********************** APPCTRL CHANGE LISTENERS *******************/
    /**
     * Whenever the height of appStage changes,
     * set the height of sideStage to match.
     */
    public ChangeListener<Number> appChangeH = new ChangeListener<Number> ()
    {
        @Override
        public void changed (ObservableValue<? extends Number> observable, Number oldValue, Number newValue)
        {
            sideStage.setHeight (appScene.getWindow ().getHeight ());
        }
    };

    /**
     * Whenever the width of appStage changes, reposition
     * sideStage horizontally by the same amount
     */
    public ChangeListener<Number> appChangeW = new ChangeListener<Number> ()
    {
        @Override
        public void changed (ObservableValue<? extends Number> observable, Number oldValue, Number newValue)
        {
            double widthDelta = newValue.doubleValue () - oldValue.doubleValue ();
            sideStage.setX (sideStage.getX () + widthDelta);
        }
    };

    /**
     * Whenever the vertical position of appStage changes,
     * reposition sideStage vertically by the same amount.
     */
    private ChangeListener<Number> appChangeY = new ChangeListener<Number> ()
    {
        @Override
        public void changed (ObservableValue<? extends Number> observable, Number oldValue, Number newValue)
        {
            double yDelta = newValue.doubleValue () - oldValue.doubleValue ();
            sideStage.setY (sideStage.getY () + yDelta);
        }
    };

    /**
     * Whenever the horizontal position of appStage changes,
     * reposition sideStage horizontally by the same amount.
     */
    private ChangeListener<Number> appChangeX = new ChangeListener<Number> ()
    {
        @Override
        public void changed (ObservableValue<? extends Number> observable, Number oldValue, Number newValue)
        {
            double xDelta = newValue.doubleValue () - oldValue.doubleValue ();
            sideStage.setX (sideStage.getX () + xDelta);
        }
    };
    

    /******************** APPCTRL FILEIO EVENT HANDLERS *****************/
    /**
     * 
     */
    public EventHandler<ActionEvent> saveFile = new EventHandler<ActionEvent> ()
    {
        @Override
        public void handle (ActionEvent e)
        {
            saveFile();
        }
    };

    /**
     * 
     */
    public EventHandler<ActionEvent> openFile = new EventHandler<ActionEvent> ()
    {
        @Override
        public void handle (ActionEvent e)
        {
            FileChooser fc = new FileChooser ();
            fc.setTitle ("Open File");

            // Set extension filter
             FileChooser.ExtensionFilter extFilter = new
             FileChooser.ExtensionFilter ("UML files (*.uml)", "*.uml");

            File file = fc.showOpenDialog (appStage);
            if (file != null)
            {
                if (!history.isEmpty ())
                {
                    Alert alert = new Alert(AlertType.CONFIRMATION);
                    alert.setTitle("Are you sure you want to proceed?");
                    alert.setHeaderText("Opening a file will delete any unsaved progress.");
                    alert.setContentText("Press \"open\" to continue. Press \"save\" to save first. Press \"cancel\" to keep working.");

                    ButtonType buttonOk = new ButtonType("Open");
                    ButtonType buttonSave = new ButtonType("Save");
                    ButtonType buttonTypeCancel = new ButtonType("Cancel", ButtonData.CANCEL_CLOSE);

                    alert.getButtonTypes().setAll(buttonOk, buttonSave, buttonTypeCancel);

                    Optional<ButtonType> result = alert.showAndWait();
                
                    if (result.get () == buttonSave)
                    {
                        saveFile ();
                        // Boolean true means this clearScreen is not undoable
                        history.clear ();
                        canvasCtrl.clearScreen (true);
                        fileIO.open (file);
                        appStage.setTitle (appName + file.getName ());
                    }
                    else if (result.get () == buttonOk)
                    {
                        history.clear ();
                        openFile (file);
                    }
                }
                else
                {
                    openFile (file);
                }
            }
        }
    };
    
    public EventHandler<ActionEvent> newFile = new EventHandler<ActionEvent> ()
    {
        @Override
        public void handle (ActionEvent e)
        {
            if (!history.isEmpty ())
            {
                Alert alert = new Alert(AlertType.CONFIRMATION);
                alert.setTitle("Unsaved Work");
                alert.setHeaderText("Are you sure you want to continue? Creating a new document will delete any unsaved progress.");
                alert.setContentText("Press \"continue\" to continue. Press \"cancel\" to keep working.");

                ButtonType buttonOk = new ButtonType("Continue");
                ButtonType buttonTypeCancel = new ButtonType("Cancel", ButtonData.CANCEL_CLOSE);

                alert.getButtonTypes().setAll(buttonOk, buttonTypeCancel);

                Optional<ButtonType> result = alert.showAndWait();
                if (result.get () == buttonOk)
                {
                    history.clear ();
                    canvasCtrl.clearScreen (true);
                    appStage.setTitle (appName + "Untitled Document");
                }                
            }
            else
            {
                history.clear ();
                canvasCtrl.clearScreen (true);
                appStage.setTitle (appName + "Untitled Document");
            }
        }
    };

    /**
     * re-launch this program in a new process
     */
    public EventHandler<ActionEvent> newWindow = new EventHandler<ActionEvent> ()
    {
        @Override
        public void handle (ActionEvent e)
        {
            try
            {
                System.out.println (AppCtrl.class.getResource ("AppCtrl.class"));
                // jar:file:/C:/Users/Liz/Desktop/umleditor.jar!/controllers/AppCtrl.class
                // 
                //...file: /C:/Users/Liz/Desktop/umleditor.jar | !/con...
                // file:/C:/Users/Liz/workspace/LParen/controllers/AppCtrl.class

                String prefix = "jar:file:";
                String postfix = ".jar!";
                String fullPath = AppCtrl.class.getResource ("AppCtrl.class").toString ();
                int begin = fullPath.indexOf (prefix) + prefix.length ();
                int end = fullPath.indexOf (postfix) + postfix.length () - 1;
                
                if (begin < end)
                {
                    //String 
                }
                
                Runtime.getRuntime ().exec ("java Main");
                Runtime.getRuntime ().exec ("java -jar ");
            } catch (IOException ex)
            {
                System.out.println ("newFile exec error");
            }
        }
    };
    
    public EventHandler<ActionEvent> exitEvent = new EventHandler<ActionEvent> ()
    {
        @Override
        public void handle (ActionEvent e)
        {
            if (!history.isEmpty ())
            {
                Alert alert = new Alert(AlertType.CONFIRMATION);
                alert.setTitle("Unsaved Work");
                alert.setHeaderText("Are you sure you want to continue? Exiting will delete any unsaved progress.");
                alert.setContentText("Press \"ok\" to continue. Press \"cancel\" to keep working.");

                ButtonType buttonOk = new ButtonType("Exit");
                ButtonType buttonTypeCancel = new ButtonType("Cancel", ButtonData.CANCEL_CLOSE);

                alert.getButtonTypes().setAll(buttonOk, buttonTypeCancel);

                Optional<ButtonType> result = alert.showAndWait();
                if (result.get () == buttonOk)
                {
                    Platform.exit();
                }                
            }
            else
            {
                Platform.exit();
            }
        }
    };
    
    /*************************** APPCTRL FUNCTIONS ***********************/  

    /**
     * 
     */
    public void saveFile ()
    {
        FileChooser fc = new FileChooser ();
        fc.setTitle ("Save File");

        // Set extension filter
         FileChooser.ExtensionFilter extFiler = new
         FileChooser.ExtensionFilter ("UML files (*.uml)", "*.uml");

        File file = fc.showSaveDialog (appStage);
        if (file != null)
        {
            fileIO.save (file);
            appStage.setTitle (appName + file.getName ());
        }
    }
    
    /**
     * 
     * @param file
     */
    public void openFile (File file)
    {
        // Boolean true means this clearScreen is not undoable
        // TODO: reset stack
        canvasCtrl.clearScreen (true);
        fileIO.open (file);
        appStage.setTitle (appName + file.getName ());
        
        int lastNode = theGraph.getAllNodes ()[theGraph.getAllNodes ().length - 1];
        canvasCtrl.setUNodeId (lastNode);
        int lastEdge = theGraph.getAllEdges ()[theGraph.getAllEdges ().length - 1];
        canvasCtrl.setUEdgeId (lastEdge);
    }
    
    /**
     * 
     */
    public void undo ()
    {
        Command undo = history.undo ();
        if (undo != null)
        {
            executeCommand (undo, true);
        }
    }
    
    /**
     * 
     */
    public void redo ()
    {
        Command redo = history.redo ();
        if (redo != null)
        {
            executeCommand (redo, true);
        }
    }

    /*********************** APPCTRL EXECUTE COMMAND ********************/  

    /**
     * Route the provided Command to the appropriate controller for 
     * execution. The value of cmd.actionScope (either CANVAS or PROPERTY)
     * determines which controller will receive the Command.
     *
     * @param cmd the command to be executed
     * @param isHistory if this value is true then the command is from the History class
     * @return a boolean value
     */
    public boolean executeCommand (Command cmd, boolean isHistory)
    {
        if (!isHistory && cmd != null)
        {
            history.push (cmd);
        }

        if (cmd.actionScope == Scope.CANVAS) {
            canvasCtrl.executeCommand (cmd, isHistory);
        }
        else if (cmd.actionScope == Scope.PROPERTY) {
            propCtrl.executeCommand (cmd, isHistory);
        }

        return false;
    }
}
